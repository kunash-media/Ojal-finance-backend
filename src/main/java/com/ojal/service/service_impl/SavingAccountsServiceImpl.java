package com.ojal.service.service_impl;

import com.ojal.global_exception.ResourceNotFoundException;
import com.ojal.model_entity.SavingAccountsEntity;
import com.ojal.model_entity.SavingAccounts_Dto.SavingAccountsDto;

import com.ojal.model_entity.UsersEntity;
import com.ojal.repository.SavingAccountsRepository;

import com.ojal.repository.UsersRepository;
import com.ojal.service.SavingAccountsService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;



@Service
public class SavingAccountsServiceImpl implements SavingAccountsService {

    private final SavingAccountsRepository savingAccountsRepository;
    private final UsersRepository userRepository;

    @Value("${account.savings.default-minimum-balance:1000}")
    private BigDecimal defaultMinimumBalance;

    @Autowired
    public SavingAccountsServiceImpl(
            SavingAccountsRepository savingAccountsRepository,
            UsersRepository userRepository) {
        this.savingAccountsRepository = savingAccountsRepository;
        this.userRepository = userRepository;
    }

    @Override
    @Transactional
    public SavingAccountsEntity createAccount(String userId, SavingAccountsDto dto) {
        // Find user
        UsersEntity user = userRepository.findByUserId(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));

        // Validate initial deposit
        BigDecimal minimumRequired = defaultMinimumBalance;
        if (dto.getInitialDeposit() == null || dto.getInitialDeposit().compareTo(minimumRequired) < 0) {
            throw new IllegalArgumentException(
                    "Initial deposit must be at least the minimum balance amount of " + minimumRequired);
        }

        // Create new savings account
        SavingAccountsEntity account = new SavingAccountsEntity();

        account.setUser(user);
//        account.setAccountName(dto.getAccountName());
        account.setBalance(dto.getInitialDeposit());
        account.setInterestRate(dto.getInterestRate());
        account.setMinimumBalance(minimumRequired);

        // The account number will be generated by the @PrePersist method in the entity

        return savingAccountsRepository.save(account);
    }

    @Override
    public SavingAccountsEntity findByAccountNumber(String accountNumber) {
        return savingAccountsRepository.findByAccountNumber(accountNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Saving Account", "accountNumber", accountNumber));
    }

    @Override
    public List<SavingAccountsEntity> findAllByUserId(String userId) {
        // Validate user exists
        if (!userRepository.existsByUserId(userId)) {
            throw new ResourceNotFoundException("User", "id", userId);
        }
        return savingAccountsRepository.findByUser_userId(userId);
    }

    @Override
    @Transactional
    public SavingAccountsEntity updateBalance(String accountNumber, BigDecimal amount) {
        SavingAccountsEntity account = findByAccountNumber(accountNumber);

        BigDecimal newBalance = account.getBalance().add(amount);

        // Validate withdrawal doesn't go below minimum balance
        if (amount.compareTo(BigDecimal.ZERO) < 0 &&
                newBalance.compareTo(account.getMinimumBalance()) < 0) {
            throw new IllegalArgumentException(
                    "Withdrawal would reduce balance below minimum required balance of " +
                            account.getMinimumBalance());
        }

        account.setBalance(newBalance);
        // The lastUpdated field will be updated by BaseAccountEntity's @PreUpdate method

        return savingAccountsRepository.save(account);
    }
}