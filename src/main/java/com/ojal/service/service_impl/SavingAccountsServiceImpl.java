package com.ojal.service.service_impl;

import com.ojal.enum_accounts.AccountType;
import com.ojal.global_exception.ResourceNotFoundException;
import com.ojal.model_entity.SavingAccountsEntity;
import com.ojal.model_entity.SavingTransactionEntity;
import com.ojal.model_entity.UsersEntity;
import com.ojal.model_entity.dto.request.SavingAccountDetailsDto;
import com.ojal.model_entity.dto.request.SavingAccountUpdateDto;
import com.ojal.model_entity.dto.request.SavingAccountsDto;
import com.ojal.model_entity.dto.request.SavingTransactionDto;
import com.ojal.repository.SavingAccountsRepository;
import com.ojal.repository.SavingTransactionRepository;
import com.ojal.repository.UsersRepository;
import com.ojal.service.SavingAccountsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class SavingAccountsServiceImpl implements SavingAccountsService {

    private final SavingAccountsRepository savingAccountsRepository;
    private final UsersRepository userRepository;
    private final SavingTransactionRepository transactionRepository;

    @Value("${account.savings.default-minimum-balance:1000}")
    private BigDecimal defaultMinimumBalance;

    @Autowired
    public SavingAccountsServiceImpl(
            SavingAccountsRepository savingAccountsRepository,
            UsersRepository userRepository,
            SavingTransactionRepository transactionRepository) {
        this.savingAccountsRepository = savingAccountsRepository;
        this.userRepository = userRepository;
        this.transactionRepository = transactionRepository;
    }

    @Override
    @Transactional
    public SavingAccountsEntity createAccount(String userId, SavingAccountsDto dto) {

        UsersEntity user = userRepository.findByUserId(userId);
        boolean alreadyAccount = savingAccountsRepository.existsByUser_UserId(userId);

        if(alreadyAccount){
            throw new ResponseStatusException(HttpStatus.CONFLICT,"Account with this number already exists: "+userId);
        }

        if(user == null){
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,"User not found with ID: "+userId);
        }
        // Validate initial deposit
        BigDecimal minimumRequired = defaultMinimumBalance;
        if (dto.getInitialDeposit() == null || dto.getInitialDeposit().compareTo(minimumRequired) < 0) {
            throw new IllegalArgumentException(
                    "Initial deposit must be at least the minimum balance amount of " + minimumRequired);
        }

        // Create new savings account
        SavingAccountsEntity account = new SavingAccountsEntity();

        account.setUser(user);

        account.setBalance(dto.getInitialDeposit());
        account.setInterestRate(dto.getInterestRate());
        account.setMinimumBalance(minimumRequired);

        // The account number will be generated by the @PrePersist method in the entity

        return savingAccountsRepository.save(account);
    }

    @Override
    public SavingAccountsEntity findByAccountNumber(String accountNumber) {
        return savingAccountsRepository.findByAccountNumber(accountNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Saving Account", "accountNumber", accountNumber));
    }

    @Override
    public SavingAccountDetailsDto getAccountWithTransactions(String accountNumber) {
        // Get the account
        SavingAccountsEntity account = findByAccountNumber(accountNumber);

        // Get associated transactions
        List<SavingTransactionEntity> transactions = transactionRepository
                .findBySavingAccount_AccountNumberOrderByCreatedAtDesc(accountNumber);

        // Create DTO
        SavingAccountDetailsDto dto = new SavingAccountDetailsDto();
        dto.setId(account.getId());
        dto.setName(account.getUser().getFirstName());
        dto.setAccountNumber(account.getAccountNumber());

        // Set creation time with format of 12hr-am/pm
        LocalDateTime now = LocalDateTime.now().truncatedTo(ChronoUnit.MINUTES);

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm a");

        String formattedTime = now.format(formatter);

        dto.setCreatedAt(formattedTime);
        dto.setAccountType(AccountType.SAVING_AC.name());
        dto.setCurrentBalance(account.getBalance());
        dto.setInterestRate(account.getInterestRate());
        dto.setStatus(account.getStatus().name());

        // Map transactions to DTOs
        List<SavingTransactionDto> transactionDtos = transactions.stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
        dto.setTransactionData(transactionDtos);

        return dto;
    }

    private SavingTransactionDto mapToDto(SavingTransactionEntity entity) {
        SavingTransactionDto dto = new SavingTransactionDto();
        dto.setId(entity.getId());
        dto.setCreatedAt(entity.getCreatedAt());
        dto.setAmount(entity.getAmount());
        dto.setPayMode(entity.getPayMode());
        dto.setUtrNo(entity.getUtrNo());
        dto.setCash(entity.getCash());
        dto.setChequeNumber(entity.getChequeNumber());
        dto.setNote(entity.getNote());
        dto.setBalanceAfter(entity.getBalanceAfter());
        return dto;
    }

    /**
     * Get saving account by user ID
     * @param userId the user ID to search for
     * @return SavingAccountsEntity if found
     * @throws ResourceNotFoundException if account not found
     */
    @Override
    public SavingAccountsEntity getAccountByUserId(String userId) {
        // First check if user exists
        UsersEntity user = userRepository.findByUserId(userId);
        if (user == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found with ID: " + userId);
        }

        // Find the saving account for this user
        return savingAccountsRepository.findByUser_UserId(userId)
                .orElseThrow(() -> new ResourceNotFoundException("Saving Account", "userId", userId));
    }

    /**
     * Update saving account by user ID (excluding account number)
     * @param userId the user ID
     * @param updateDto the update data
     * @return updated SavingAccountsEntity
     * @throws ResourceNotFoundException if account not found
     */
    @Transactional
    @Override
    public SavingAccountsEntity updateAccountByUserId(String userId, SavingAccountUpdateDto updateDto) {
        // Find existing account
        SavingAccountsEntity existingAccount = getAccountByUserId(userId);

        // Update fields (excluding account number for security)
        if (updateDto.getInterestRate() != null) {
            // Validate interest rate (should be positive and reasonable)
            if (updateDto.getInterestRate().compareTo(BigDecimal.ZERO) <= 0 ||
                    updateDto.getInterestRate().compareTo(new BigDecimal("20")) > 0) {
                throw new IllegalArgumentException("Interest rate must be between 0 and 20 percent");
            }
            existingAccount.setInterestRate(updateDto.getInterestRate());
        }

        if (updateDto.getMinimumBalance() != null) {
            // Validate minimum balance (should not be negative)
            if (updateDto.getMinimumBalance().compareTo(BigDecimal.ZERO) < 0) {
                throw new IllegalArgumentException("Minimum balance cannot be negative");
            }

            // Check if current balance meets new minimum balance requirement
            if (existingAccount.getBalance().compareTo(updateDto.getMinimumBalance()) < 0) {
                throw new IllegalArgumentException(
                        "Cannot set minimum balance higher than current balance. Current balance: " +
                                existingAccount.getBalance() + ", Requested minimum: " + updateDto.getMinimumBalance());
            }

            existingAccount.setMinimumBalance(updateDto.getMinimumBalance());
        }

        // Save and return updated account
        return savingAccountsRepository.save(existingAccount);
    }

    /**
     * Get all saving accounts by branch name
     * @param branchName the branch name to filter by
     * @return List of SavingAccountsEntity
     * @throws IllegalArgumentException if branch name is null or empty
     */
    @Override
    public List<SavingAccountsEntity> getAllAccountsByBranch(String branchName) {
        // Validate branch name
        if (branchName == null || branchName.trim().isEmpty()) {
            throw new IllegalArgumentException("Branch name cannot be null or empty");
        }

        // Find all accounts for the specified branch
        List<SavingAccountsEntity> accounts = savingAccountsRepository.findByUser_Branch(branchName.trim());

        // Log the operation for audit purposes
        System.out.println("Retrieved " + accounts.size() + " saving accounts for branch: " + branchName);

        return accounts;
    }

    /**
     * Delete saving account by user ID
     * @param userId the user ID
     * @return success message
     * @throws ResourceNotFoundException if account not found
     * @throws IllegalStateException if account has pending transactions or non-zero balance
     */
    @Override
    @Transactional
    public String deleteAccountByUserId(String userId) {
        // First verify the account exists
        SavingAccountsEntity account = getAccountByUserId(userId);

        // Business rule: Don't allow deletion if account has balance
        if (account.getBalance().compareTo(BigDecimal.ZERO) != 0) {
            throw new IllegalStateException(
                    "Cannot delete account with non-zero balance. Current balance: " + account.getBalance());
        }

        // Additional check: Verify no pending transactions (optional)
        List<SavingTransactionEntity> recentTransactions = transactionRepository
                .findBySavingAccount_AccountNumberOrderByCreatedAtDesc(account.getAccountNumber());

        // If there are recent transactions, you might want to prevent deletion
        // This is a business decision - commenting out for now
        /*
        if (!recentTransactions.isEmpty()) {
            throw new IllegalStateException(
                "Cannot delete account with transaction history. Please contact administrator.");
        }
        */

        // Perform the deletion
        int deletedCount = savingAccountsRepository.deleteByUser_UserId(userId);

        if (deletedCount == 0) {
            throw new IllegalStateException("Failed to delete account for user: " + userId);
        }

        return "Successfully deleted saving account for user: " + userId;
    }
}